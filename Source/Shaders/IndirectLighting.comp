// Copyright(c) 2022 Jounayd Id Salah
#version 460
#extension GL_GOOGLE_include_directive : enable 
#extension GL_EXT_nonuniform_qualifier : enable

#define GLOBAL_UBO_DESC_SET_IDX 0
#include "GlobalUBO.h"

#define GLOBAL_TEXTURES_DESC_SET_IDX 1
#include "GlobalTextures.h"

#define GLOBAL_STORAGE_DESC_SET_IDX 2
#include "GlobalStorage.h"

#include "Base.glsl"
#include "Compression.glsl"
#include "Noise.glsl"
#include "RayTrace.glsl"
#include "PTRayGen.h"
#include "Brdf.glsl"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(constant_id = 0) const uint spec_bounce_index = 0;

const vec3 ambient = vec3(0);
const float lightPower = 100.0f;
const vec3 lightPos = vec3(0, 0, 0);
const vec3 lightColor = vec3(1, 1, 1);


vec3 RandomUnitVector2(float rngX, float rngY)
{
	float z = rngX * 2.0f - 1.0f;
	float a = rngY * PI * 2.0f;
	float r = sqrt(1.0f - z * z);
	vec2 xy = vec2(cos(a), sin(a)) * r;
	return vec3(xy, z);
}

// Random cosine-weighted unit vector on a hemisphere
// Unit vector + random unit vector
vec3 RandomCosineHemisphere2(vec3 n)
{
	return normalize(RandomUnitVector2(get_rng(RNG_BRDF_X(spec_bounce_index+1)), get_rng(RNG_BRDF_Y(spec_bounce_index+1))) + n);
}

void main()
{
	ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
	const int halfWidth = _globalUBO._width / 2;
	if(any(greaterThanEqual(ipos, ivec2(halfWidth, _globalUBO._height))))
		return;

	if (gl_GlobalInvocationID.z != 0)
		ipos.x += halfWidth;
	
	vec4 posAndMat = texelFetch(TEX_PT_SHADING_POSITION, ipos, 0);
	uint materialID = floatBitsToUint(posAndMat.w);
	if (materialID == 0)
		return;

	vec3 position = posAndMat.xyz;

	rng_seed = texelFetch(TEX_ASVGF_RNG_SEED_A, ipos, 0).r;

	vec4 throughput = texelFetch(TEX_PT_BOUNCE_THROUGHPUT, ipos, 0);

	const bool isLastBounce = spec_bounce_index == (_globalUBO.pt_num_bounce_rays - 1);
	vec4 view_direction;
	vec3 normal;
    vec3 geo_normal;
    vec4 primary_base_color = vec4(0);
    float primary_metallic = 0;
	float primary_roughness = 1;
	float primary_specular_factor = 0;
	if (spec_bounce_index == 0)
	{
		// First bounce: use primary/reflected view direction,
		// actual normals of the surface, and specular parameters
		// (unless GI is set to "low", which means half res and no specular)

	    view_direction = texelFetch(TEX_PT_VIEW_DIRECTION, ipos, 0);
		normal = decode_normal(texelFetch(TEX_PT_NORMAL_A, ipos, 0).x);
	    geo_normal = decode_normal(texelFetch(TEX_PT_GEO_NORMAL_A, ipos, 0).x);
	    primary_base_color = texelFetch(TEX_PT_BASE_COLOR_A, ipos, 0);
	    primary_specular_factor = primary_base_color.a;
		vec2 metal_rough = texelFetch(TEX_PT_METALLIC_A, ipos, 0).xy;
		primary_metallic = metal_rough.x;
		primary_roughness = metal_rough.y;
	}
	else
	{
		// Second bounce: use the first bounce view direction,
		// and the geo normal of the first bounce surface.
		// These have to be stored in textures different from the primary
		// surface params, because the primary view direction and normal
		// are used for fake specular reconstruction (see `asvgf_atrous.comp`)
		// and for LF channel filtering, respectively.

	    view_direction = texelFetch(TEX_PT_VIEW_DIRECTION2, ipos, 0);
	    geo_normal = decode_normal(texelFetch(TEX_PT_GEO_NORMAL2, ipos, 0).x);
		normal = geo_normal;
	}

	vec3 primary_albedo, primary_base_reflectivity;
	get_reflectivity(primary_base_color.rgb, primary_metallic, primary_albedo, primary_base_reflectivity);

	float direct_specular_weight = smoothstep(
		_globalUBO.pt_direct_roughness_threshold - 0.02, 
		_globalUBO.pt_direct_roughness_threshold + 0.02, 
		primary_roughness);

	float fake_specular_weight = smoothstep(
		_globalUBO.pt_fake_roughness_threshold, 
		_globalUBO.pt_fake_roughness_threshold + 0.1, 
		primary_roughness);

	float NoV = max(0, -dot(normal, view_direction.xyz));
	bool first_bounce_is_specular = throughput.a != 0;
	vec3 bounce_throughput = throughput.xyz;
	const float maxDist = maxTraceDist;

	vec3 basis_normal = geo_normal;
	vec3 bounce_direction;

	bool is_specular_ray = false;
	{
		vec2 rng3 = vec2(get_rng(RNG_BRDF_X(spec_bounce_index+1)), get_rng(RNG_BRDF_Y(spec_bounce_index+1)));
		float specular_pdf = 0;
		if(spec_bounce_index == 0)
		{
			specular_pdf = (primary_metallic == 1 && fake_specular_weight == 0) ? 1.0 : 0.5;

			float rng_fresnel = get_rng(RNG_BRDF_FRESNEL(spec_bounce_index+1));
			if(rng_fresnel < specular_pdf) 
			{
				mat3 basis = construct_ONB_frisvad(normal);

				// Sampling of normal distribution function to compute the reflected ray.
				// See the paper "Sampling the GGX Distribution of Visible Normals" by E. Heitz, 
				// Journal of Computer Graphics Techniques Vol. 7, No. 4, 2018.
				// http://jcgt.org/published/0007/04/01/paper.pdf 

				vec3 N = normal;
				vec3 V = view_direction.xyz;
				vec3 H = ImportanceSampleGGX_VNDF(rng3, primary_roughness, V, basis);
				vec3 L = reflect(V, H);

				float NoL = max(0, dot(N, L));
				float NoH = max(0, dot(N, H));
				float VoH = max(0, -dot(V, H));

				if (NoL > 0 && NoV > 0)
				{
					// See the Heitz paper referenced above for the estimator explanation.
					//   (BRDF / PDF) = F * G2(V, L) / G1(V)
					// Assume G2 = G1(V) * G1(L) here and simplify that expression to just G1(L).
					
					float G1_NoL = G1_Smith(primary_roughness, NoL);
					vec3 F = schlick_fresnel(primary_base_reflectivity, VoH, primary_specular_factor);

					bounce_throughput *= G1_NoL * F;

					bounce_throughput *= 1 / specular_pdf;
					is_specular_ray = true;
					bounce_direction = normalize(L);
				}
			}
		}
		if (!is_specular_ray)
		{
			vec3 basis_normal, dir_sphere;
			if (spec_bounce_index == 0 && _globalUBO.flt_enable != 0)
			{
				dir_sphere = sample_cos_hemisphere_multi(0, 1, rng3, HEMISPHERE_UNIFORMISH);
				basis_normal = geo_normal;
			}
			else
			{
				dir_sphere = sample_cos_hemisphere(rng3);
				basis_normal = normal;
			}

			mat3 basis = construct_ONB_frisvad(basis_normal);
			bounce_direction = normalize(basis * dir_sphere);
			bounce_throughput *= 1 / (1 - specular_pdf);

			vec3 L = bounce_direction.xyz;
			vec3 V = -view_direction.xyz;
			vec3 H = normalize(V + L);
			float VoH = max(0, dot(V, H));

			vec3 F = schlick_fresnel(primary_base_reflectivity, VoH, primary_specular_factor);

			bounce_throughput *= vec3(1.0) - F;
		}
	}

	Ray r;
	r.o = position;
	r.d = bounce_direction;
	r._maxDist = maxTraceDist;

	//r.o -= view_direction.xyz * 0.01;
	r.o += geo_normal.xyz * 0.01f;

	//imageStore(IMG_TAA_OUTPUT, ipos, vec4(r.d, 1));
	//return;

	//r.o = vec3(0, 0, 0);
	//r.d = vec3(100, 0, 0);

	//imageStore(IMG_TAA_OUTPUT, ipos, vec4(1, 0, 0, 1));
	//return;

	CastResult result;
	CastGlobal(r, result);

	
	//imageStore(IMG_TAA_OUTPUT, ipos, vec4(1, 0, 0, 1));
	//return;
	
	if (result._t >= r._maxDist)
	{
		if (!isLastBounce)
			imageStore(IMG_PT_SHADING_POSITION, ipos, vec4(0));
		return;
	}

	vec3 bounce_contrib = vec3(0);

	//imageStore(IMG_TAA_OUTPUT, ipos, vec4(1, 0, 0, 1));
	//return;
	
	const float hitDist = result._t;

	float indirect_specular_weight = 1;

	if (is_specular_ray)
	{
		float cone_size = hitDist * primary_roughness;
		indirect_specular_weight = 1 - fake_specular_weight;
		indirect_specular_weight /= max(1, cone_size * _globalUBO.pt_specular_anti_flicker * 0.01);
	}

	vec3 bounce_geo_normal = result._normal;
	vec3 bounce_normal  = bounce_geo_normal;
	vec3 bounce_base_color = vec3(0.8);

	// HACK
	/*
	if (result._normal.z < -0.9f)
	{
		bounce_base_color = vec3(0.9f, 0.15f, 0.3f);
		vec3 emissive = bounce_base_color * _globalUBO._fakeEmissive;
		bounce_contrib += emissive * bounce_throughput * indirect_specular_weight;
	}
	*/

	if (dot(bounce_direction, bounce_normal) > 0)
		bounce_normal = -bounce_normal;

	bounce_throughput *= bounce_base_color;
	bounce_throughput *= indirect_specular_weight;

	// Russian Roulette
	// As the throughput gets smaller, the ray is more likely to get terminated early.
	// Survivors have their value boosted to make up for fewer samples being in the average.
	if (true)
	{
		float p = max(bounce_throughput.x, max(bounce_throughput.y, bounce_throughput.z));
		if (p < RandomFloat01(rng_seed))
		{
			if (!isLastBounce)
				imageStore(IMG_PT_SHADING_POSITION, ipos, vec4(0.0f));
			return;
		}
    
		// Add the energy we 'lose' by randomly terminating paths
		bounce_throughput *= 1.0f / p;
	}
	
	vec3 bounce_position = r.o + r.d * result._t;
	uint bounce_materialID = 1;

	// HACK
	if (isLastBounce)
	{
		imageStore(IMG_PT_GEO_NORMAL2, ipos, uvec4(encode_normal(bounce_geo_normal)));
		imageStore(IMG_PT_SHADING_POSITION, ipos, vec4(bounce_position.xyz, hitDist));
		/*if (result._normal.z < -0.9f)
			imageStore(IMG_PT_BOUNCE_THROUGHPUT, ipos, vec4(1.0f));
		else*/
			imageStore(IMG_PT_BOUNCE_THROUGHPUT, ipos, vec4(0.0f));
	}

	if (!isLastBounce)
	{
		imageStore(IMG_PT_GEO_NORMAL2, ipos, uvec4(encode_normal(bounce_geo_normal)));
		imageStore(IMG_PT_SHADING_POSITION, ipos, vec4(bounce_position.xyz, uintBitsToFloat(bounce_materialID)));
		imageStore(IMG_PT_VIEW_DIRECTION2, ipos, vec4(bounce_direction, 0));
		imageStore(IMG_PT_BOUNCE_THROUGHPUT, ipos, vec4(bounce_throughput, is_specular_ray ? 1 : 0));
	}

	if (is_specular_ray)
		bounce_contrib = demodulate_specular(primary_base_reflectivity, bounce_contrib);

	if(spec_bounce_index > 0 && first_bounce_is_specular)
		is_specular_ray = true;

	if(spec_bounce_index > 0)
		bounce_direction = view_direction.xyz;

	
	if(any(isinf(bounce_contrib)) || any(isnan(bounce_contrib)) || any(isinf(bounce_direction)) || any(isnan(bounce_direction)) )
		return;
/*
	bounce_contrib = clamp(bounce_contrib, 0, 1000.0f);
	*/

	if (all(equal(bounce_contrib, vec3(0))))
		return;

	if (is_specular_ray)
	{
		bounce_contrib *= STORAGE_SCALE_SPEC;

		vec3 specular = unpackRGBE(imageLoad(IMG_PT_COLOR_SPEC, ipos).x);
		specular += bounce_contrib;
		imageStore(IMG_PT_COLOR_SPEC, ipos, uvec4(packRGBE(specular)));
	}
	else
	{
		bounce_contrib *= STORAGE_SCALE_LF;

		SH low_freq = load_SH(TEX_PT_COLOR_LF_SH, TEX_PT_COLOR_LF_COCG, ipos);

		if (_globalUBO.flt_enable == 0)
			low_freq.shY.xyz += bounce_contrib;
		else
			accumulate_SH(low_freq, irradiance_to_SH(bounce_contrib, bounce_direction), 1.0);

		STORE_SH(IMG_PT_COLOR_LF_SH, IMG_PT_COLOR_LF_COCG, ipos, low_freq);
	}
}
