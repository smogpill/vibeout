// Copyright(c) 2022 Jounayd Id Salah
#version 460
#extension GL_GOOGLE_include_directive : enable 
#extension GL_EXT_nonuniform_qualifier : enable

#define GLOBAL_UBO_DESC_SET_IDX 0
#include "GlobalUBO.h"

#define GLOBAL_TEXTURES_DESC_SET_IDX 1
#include "GlobalTextures.h"

#define GLOBAL_VOXEL_DESC_SET_IDX 2
#include "VoxelBuffer.h"

#define GLOBAL_STORAGE_DESC_SET_IDX 3
#include "GlobalStorage.h"

#include "Lighting.glsl"
#include "Geometry.glsl"
#include "Compression.glsl"
#include "Noise.glsl"
#include "RayTrace.glsl"
#include "PTRayGen.h"

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(constant_id = 0) const uint spec_enable_caustics = 0;

const vec3 ambient = vec3(0);
const float lightPower = 100.0f;
const vec3 lightColor = vec3(1, 1, 1);
//const float emittanceMultiplier = 10.0f;

void main()
{
	ivec2 ipos = ivec2(gl_GlobalInvocationID.xy);
	const int halfWidth = _globalUBO._width / 2;
	if(any(greaterThanEqual(ipos, ivec2(halfWidth, _globalUBO._height))))
		return;
	bool is_odd_checkerboard = gl_GlobalInvocationID.z != 0;
	if (is_odd_checkerboard)
		ipos.x += halfWidth;

	imageStore(IMG_PT_COLOR_LF_SH, ipos, vec4(0));
	imageStore(IMG_PT_COLOR_LF_COCG, ipos, vec4(0));

	vec4 posAndMat = texelFetch(TEX_PT_SHADING_POSITION, ipos, 0);
	uint material_id = floatBitsToUint(posAndMat.w);
	if (material_id == 0)
	{
		imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(vec3(0))));
		imageStore(IMG_PT_COLOR_SPEC, ipos, uvec4(packRGBE(vec3(0))));
		return;
	}

	vec3 pos = posAndMat.xyz;
	const vec3 normal = decode_normal(texelFetch(TEX_PT_NORMAL_A, ipos, 0).x);
	const vec3 geoNormal = decode_normal(texelFetch(TEX_PT_GEO_NORMAL_A, ipos, 0).x);
	vec4 primary_base_color = texelFetch(TEX_PT_BASE_COLOR_A, ipos, 0);
	float primary_specular_factor = primary_base_color.a;
	vec2 metal_rough = texelFetch(TEX_PT_METALLIC_A, ipos, 0).xy;

	rng_seed = texelFetch(TEX_ASVGF_RNG_SEED_A, ipos, 0).r;

	vec3 high_freq = vec3(0);
	vec3 specular = vec3(0);
	
	pos += geoNormal * 0.01f;
	vec3 lightPos = _globalUBO._camPos;
    //return vec3(0);
	//vec3 lightPos = (inverse(invView) * vec4(0, 0, 0, 1)).xyz;
	//vec3 lightPos = vec3(0, 0, 10.0f);
	vec3 ligthSamplePos = lightPos + vec3(RandomFloat01(rng_seed), RandomFloat01(rng_seed), RandomFloat01(rng_seed)) * 1.0f;
	float lightPower = 100.0f;
	//vec3 lightColor = vec3(.6, .75, .95) * lightPower;
	vec3 lightColor = vec3(1.00, 0.99, .95);

	vec3 posToLight = ligthSamplePos - pos;
	float distance2 = max(0.001, dot(posToLight, posToLight));
    float attenuation = 1.0 / distance2;
	float radianceMag = attenuation * lightPower;

	if (radianceMag > 0.0000001f)
	//if (false)
	{
		// Shadow ray
		Ray r;
		r.o = pos;
		r.d = posToLight;

		vec3 hitNorm;
		vec4 result = CastGlobal(r, _globalUBO._drawVoxelLevel, hitNorm);
		if (result.x < 0)
		{
			const vec3 lighting = max(0, dot(normal, normalize(r.d))) * lightColor * radianceMag;
	
			high_freq += lighting;
		}
	}

	high_freq *= STORAGE_SCALE_HF;
	specular *= STORAGE_SCALE_SPEC;
	imageStore(IMG_PT_COLOR_HF, ipos, uvec4(packRGBE(high_freq)));
	imageStore(IMG_PT_COLOR_SPEC, ipos, uvec4(packRGBE(specular)));

	/*
    vec3 fragPos = GetFragPos(invViewProj, uv, depth);
    vec3 light = lightColor * lightPower;
    vec3 viewDir = normalize(lightPos - fragPos);

    vec3 F0 = ComputeF0(albedo, metallic); 
	           
    // Reflectance
    vec3 reflectance = Reflectance(fragPos, normal, lightPos, light, viewDir, albedo, roughness, metallic, F0);
    //vec3 reflectance = ReflectanceForIndirectLighting(fragPos, normal, lightPos, light, metallic);

    outColor.xyz = (ambient * ambientOcclusion + vec3(emittance)) * albedo + reflectance;
    //outColor.xyz = abs(fragPos / 100.0f);
    //outColor.xyz = abs(normal);
    outColor.w = 1.0f;
    */
}
